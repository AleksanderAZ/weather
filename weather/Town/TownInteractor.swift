//
//  TownInteractor.swift
//  weather
//
//  Created Z on 6/11/19.
//  Copyright © 2019 Zyma. All rights reserved.
//
//  Template generated by Juanpe Catalán @JuanpeCMiOS
//

import UIKit

class TownInteractor: TownInteractorProtocol {

    weak var presenter: TownPresenterProtocol?
    
    let townDataBase: TownDataBaseProtocol = TownDataBase()
    private var nameTowns = [String]()
    private var townModel: [TownModel]?
    
    
    func appendLoadTown(index: Int, count: Int) {
      print(index,"----")
        
         let item = self.nameTowns[index]
         loadTownInfo(nameTown: item) { [weak self] (name: String?, tempr: String?, info: String?) in
            self?.townModel?.append(TownModel(name: item, temperature: tempr, townFullInfo: info, typeInfo: false))
            let i = index + 1
            if i >= count {
                self?.presenter?.updata(towns: self?.townModel)
            }
            else {
                print("-------",i,"--------")
                self?.appendLoadTown(index: i, count: count)
            }
         }
    }
    
    func loadTown() {
        let index: Int = 0
        let count = townDataBase.count()
        if count > 0 {
            townModel?.removeAll()
            nameTowns.removeAll()
            for i in 0..<count {
                let item = townDataBase.getItem(index: i)
                self.nameTowns.append(item)
            }
            self.appendLoadTown(index: index, count: count)
        }
    }
    
    func getTown(completion: @escaping ([TownModel]?)->()) {
        
        if let townModel = self.townModel {
            completion(townModel)
        }
        else {
            self.townModel = [TownModel]()
            self.loadTown()
        }
    }
    
    func addTown(name: String) {
        
        let itemsTowns = self.townModel?.filter { (item) in
            guard let itemName = item.name else { return false }
            return (name == itemName)
        }
        
        let isTowns = itemsTowns?.count ?? 0
        print(isTowns)
        if  isTowns == 0 {
            self.loadTownInfo(nameTown: name) { [weak self] (name: String?, tempr: String?, info: String?) in
                DispatchQueue.main.async {
                    if let name = name {
                        self?.townDataBase.addItem(item: name)
                        self?.loadTown()
                    }
                }
            }
        }
    }
    
    func loadTownInfo(nameTown: String, completion: @escaping (String?, String?, String?)->()) {
        
        NetworkServiceAPI.shared.loadAPIRequestTown(nameTown: nameTown) { [weak self] (result: TownAPIModel?) in
            
            guard let result = result else { return }
            
            let name: String = result.name ?? ""
            var tempr: String = ""
            var lon: String = ""
            var lat: String = ""
            var date: String = ""
            
            if let temp = result.main?.temp {
              tempr = String(temp)
            }
            if let l = result.coord?.lon {
                lon = String(l)
            }
            if let l = result.coord?.lat {
                lat = String(l)
            }
            if let d = result.dt {
                let dateUTS = Date(timeIntervalSince1970: d)
                let dateFormatter = DateFormatter()
                dateFormatter.dateFormat = "yyyy-MM-dd HH:mm"                 // Note: S is fractional second
                date = dateFormatter.string(from: dateUTS)
            }
            let info = "coord: " + " lon=" + lon + " lat=" + lat + "\ndata - " + date + " (UTC)"
            
            completion(name, tempr, info)
        }
    }
}
